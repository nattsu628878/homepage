<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Nattsu</title>
  <link rel="icon" type="image/x-icon" href="./favicon_io/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="./favicon_io/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="./favicon_io/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="./favicon_io/apple-touch-icon.png">
  <link rel="manifest" href="./favicon_io/site.webmanifest">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      overflow: hidden;
      background: #000;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
    }
    
    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    
    .info {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #fff;
      z-index: 10;
      pointer-events: none;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
    }
    
    .info h1 {
      font-size: 24px;
      margin-bottom: 8px;
    }
    
    .info p {
      font-size: 14px;
      opacity: 0.8;
    }
    
    .star-label {
      position: absolute;
      color: #fff;
      font-size: 12px;
      pointer-events: none;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
      opacity: 0;
      transition: opacity 0.3s;
      white-space: nowrap;
    }
    
    .star-label.visible {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="canvas-container">
    <div class="info">
      <h1 style="color: #628878;">Nattsu
      </h1>
    </div>
  </div>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    
    // シーンの設定
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    
    // カメラの設定
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 50;
    
    // レンダラーの設定
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);
    
    // 星のグループ
    const starsGroup = new THREE.Group();
    const stars = [];
    const planets = []; // 惑星（親星）
    const satellites = []; // 衛星（子星）
    const ringsGroup = new THREE.Group(); // リング用のグループ
    const shootingStars = []; // 流れ星の配列
    let lastShootingStarTime = 0; // 最後に流れ星を生成した時刻
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    // 設定とデータを読み込む
    let starConfig = null;
    let starsData = [];
    
    // 設定を読み込む
    async function loadConfig() {
      try {
        const res = await fetch('./stars/config.json');
        starConfig = await res.json();
        console.log('Config loaded:', starConfig);
      } catch (e) {
        console.error('Failed to load config:', e);
        // デフォルト設定を使用
        starConfig = {
          starTypes: {
            page: { size: 1.5, glowSize: 2.0, glowOpacity: 0.3, emissiveIntensity: 0.5 }
          },
          animation: { duration: 2000, cameraDistance: 5, scaleMultiplier: 2.0 },
          background: { starCount: 200, starSize: 0.1, starOpacity: 0.5 },
          camera: { fov: 75, near: 0.1, far: 1000, initialZ: 50 },
          controls: { enableDamping: true, dampingFactor: 0.05, minDistance: 20, maxDistance: 200 }
        };
      }
    }
    
    // 星のデータを読み込む
    async function loadStarsData() {
      try {
        const res = await fetch('./stars/data.json');
        starsData = await res.json();
        console.log('Stars data loaded:', starsData);
      } catch (e) {
        console.error('Failed to load stars data:', e);
        starsData = [];
      }
    }
    
    // コントロールの設定（マウスで回転・ズーム可能）
    const controls = new OrbitControls(camera, renderer.domElement);
    
    // 設定を適用（読み込み後に更新される）
    function applyConfig() {
      if (starConfig && starConfig.controls) {
        controls.enableDamping = starConfig.controls.enableDamping;
        controls.dampingFactor = starConfig.controls.dampingFactor;
        controls.minDistance = starConfig.controls.minDistance;
        controls.maxDistance = starConfig.controls.maxDistance;
      } else {
        // デフォルト値
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 20;
        controls.maxDistance = 200;
      }
      
      if (starConfig && starConfig.camera) {
        camera.fov = starConfig.camera.fov;
        camera.near = starConfig.camera.near;
        camera.far = starConfig.camera.far;
        camera.position.z = starConfig.camera.initialZ;
        camera.updateProjectionMatrix();
      }
    }
    
    // 星を作成
    function createStars() {
      // まず全ての星を作成（親子関係を構築するため）
      const starMap = new Map(); // id -> star のマッピング
      
      starsData.forEach((data, index) => {
        // 色を数値に変換
        let colorValue = typeof data.color === 'string' ? parseInt(data.color, 16) : data.color;
        
        // 色の彩度を下げる（HSL色空間で彩度を0.7倍にする）
        const colorObj = new THREE.Color(colorValue);
        const hsl = { h: 0, s: 0, l: 0 };
        colorObj.getHSL(hsl);
        hsl.s *= 0.7; // 彩度を70%に下げる
        colorObj.setHSL(hsl.h, hsl.s, hsl.l);
        const color = colorObj.getHex();
        
        // タイプに応じた設定を取得
        const type = data.type || 'page';
        const typeConfig = starConfig?.starTypes?.[type] || starConfig?.starTypes?.page || {
          size: 1.5,
          glowSize: 2.0,
          glowOpacity: 0.3,
          emissiveIntensity: 0.5
        };
        
        // 星の形状（球体）
        const geometry = new THREE.SphereGeometry(typeConfig.size, 16, 16);
        const material = new THREE.MeshBasicMaterial({ 
          color: color,
          emissive: color,
          emissiveIntensity: typeConfig.emissiveIntensity
        });
        const star = new THREE.Mesh(geometry, material);
        
        // 位置を設定（衛星の場合は後で軌道計算で更新）
        if (type === 'satellite' && data.parentId) {
          // 衛星の場合は親星の位置に一時的に設定（後で軌道計算で更新）
          star.position.set(0, 0, 0);
        } else {
          star.position.set(...data.position);
        }
        
        // データを保存
        star.userData = {
          id: data.id || `star-${index}`,
          name: data.name,
          url: data.url,
          type: type,
          description: data.description || '',
          external: data.external || false,
          index: index,
          // 衛星の軌道情報
          parentId: data.parentId || null,
          orbitRadius: data.orbitRadius || 10,
          orbitSpeed: data.orbitSpeed || 0.5,
          orbitAngle: data.orbitAngle || 0,
          orbitTime: 0 // 軌道計算用の時間
        };
        
        // 光る効果（グロー）
        const glowGeometry = new THREE.SphereGeometry(typeConfig.glowSize, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: typeConfig.glowOpacity
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        star.add(glow);
        
        // 衛星はstarsGroupに追加せず、後でシーンに直接追加（starsGroupの回転の影響を受けないように）
        if (type === 'satellite') {
          // 衛星は後で追加
          satellites.push(star);
        } else {
          starsGroup.add(star);
        }
        
        stars.push(star);
        starMap.set(star.userData.id, star);
        
        // 惑星を分類
        if (type === 'planet') {
          planets.push(star);
        }
      });
      
      // 衛星の親星参照を設定
      satellites.forEach(satellite => {
        if (satellite.userData.parentId) {
          const parent = starMap.get(satellite.userData.parentId);
          if (parent) {
            satellite.userData.parent = parent;
            // 親星に衛星がいることを記録
            if (!parent.userData.hasSatellites) {
              parent.userData.hasSatellites = true;
              parent.userData.satellites = []; // 衛星の配列を初期化
            }
            parent.userData.satellites.push(satellite);
          }
        }
      });
      
      // 衛星を持つ惑星にリングを追加
      planets.forEach(planet => {
        if (planet.userData.hasSatellites) {
          createRings(planet);
        }
      });
    }
    
    // 太陽を作成（ワールド座標の中心に配置）
    function createSun() {
      const sunColor = 0xffd700; // 金色
      const sunSize = 4.0; // 大きめのサイズ
      const sunGlowSize = 6.0; // 大きなグロー効果
      
      // 太陽の形状（球体）
      const geometry = new THREE.SphereGeometry(sunSize, 32, 32);
      const material = new THREE.MeshBasicMaterial({ 
        color: sunColor,
        emissive: sunColor,
        emissiveIntensity: 1.0 // 強い発光
      });
      const sun = new THREE.Mesh(geometry, material);
      
      // ワールド座標の中心に配置
      sun.position.set(0, 0, 0);
      
      // データを保存
      sun.userData = {
        id: 'sun',
        name: 'About',
        url: './sun.html',
        type: 'sun',
        description: '自己紹介',
        isSun: true
      };
      
      // 光る効果（グロー）- 複数層でより明るく
      for (let i = 0; i < 3; i++) {
        const glowGeometry = new THREE.SphereGeometry(sunGlowSize - i * 0.5, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: sunColor,
          transparent: true,
          opacity: 0.3 - i * 0.1
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        sun.add(glow);
      }
      
      // シーンに直接追加（starsGroupの回転の影響を受けない）
      scene.add(sun);
      
      return sun;
    }
    
    // リングを作成
    function createRings(planet) {
      const ringConfig = starConfig?.rings || {
        count: 3,
        baseRadius: 8,
        width: 0.1,
        segments: 64,
        opacity: 0.5,
        rotationSpeed: 0.2,
        radiusDecrease: 1.5
      };
      
      const planetSatellites = planet.userData.satellites || [];
      
      // 衛星の数だけリングを作成（各リングは対応する衛星の色を使用）
      for (let i = 0; i < planetSatellites.length; i++) {
        const satellite = planetSatellites[i];
        let satelliteColor = satellite.material.color.getHex();
        
        // リングの色の彩度も下げる（HSL色空間で彩度を0.7倍にする）
        const ringColorObj = new THREE.Color(satelliteColor);
        const ringHsl = { h: 0, s: 0, l: 0 };
        ringColorObj.getHSL(ringHsl);
        ringHsl.s *= 0.7; // 彩度を70%に下げる
        ringColorObj.setHSL(ringHsl.h, ringHsl.s, ringHsl.l);
        satelliteColor = ringColorObj.getHex();
        
        // 内側ほど半径を小さく（外側から内側へ）
        const radius = ringConfig.baseRadius - (i * ringConfig.radiusDecrease);
        const innerRadius = radius - ringConfig.width / 2;
        const outerRadius = radius + ringConfig.width / 2;
        
        // 衛星の軌道半径をリングの半径に合わせる
        satellite.userData.orbitRadius = radius;
        
        const ringGeometry = new THREE.RingGeometry(
          innerRadius,
          outerRadius,
          ringConfig.segments
        );
        
        const ringMaterial = new THREE.MeshBasicMaterial({
          color: satelliteColor,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: ringConfig.opacity,
          emissive: satelliteColor,
          emissiveIntensity: 0.3
        });
        
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        
        // XY平面に配置
        ring.rotation.x = Math.PI / 2;
        
        // リングを専用のグループに追加（親星のスケールの影響を受けないように）
        ringsGroup.add(ring);
        
        // リングの回転速度を保存（内側ほど少し速く）
        ring.userData.rotationSpeed = ringConfig.rotationSpeed * (1 + i * 0.05);
        
        // リングの初期角度を衛星の初期角度に合わせる
        ring.rotation.z = satellite.userData.orbitAngle;
        
        // リングと衛星、親星の対応関係を保存
        ring.userData.satellite = satellite;
        ring.userData.planet = planet; // 親星への参照を保存
        satellite.userData.ring = ring;
      }
    }
    
    // 流れ星を作成
    function createShootingStar() {
      // 画面の端からランダムな位置を開始点とする
      const side = Math.floor(Math.random() * 4); // 0: 上, 1: 右, 2: 下, 3: 左
      let startX, startY, endX, endY;
      
      const width = window.innerWidth;
      const height = window.innerHeight;
      
      // カメラの視野角を考慮して3D座標に変換
      const fov = camera.fov * (Math.PI / 180);
      const distance = 50; // カメラからの距離
      const aspect = width / height;
      
      switch (side) {
        case 0: // 上から
          startX = (Math.random() - 0.5) * width / distance;
          startY = Math.tan(fov / 2) * distance;
          endX = (Math.random() - 0.5) * width / distance;
          endY = -Math.tan(fov / 2) * distance;
          break;
        case 1: // 右から
          startX = Math.tan(fov / 2) * aspect * distance;
          startY = (Math.random() - 0.5) * height / distance;
          endX = -Math.tan(fov / 2) * aspect * distance;
          endY = (Math.random() - 0.5) * height / distance;
          break;
        case 2: // 下から
          startX = (Math.random() - 0.5) * width / distance;
          startY = -Math.tan(fov / 2) * distance;
          endX = (Math.random() - 0.5) * width / distance;
          endY = Math.tan(fov / 2) * distance;
          break;
        case 3: // 左から
          startX = -Math.tan(fov / 2) * aspect * distance;
          startY = (Math.random() - 0.5) * height / distance;
          endX = Math.tan(fov / 2) * aspect * distance;
          endY = (Math.random() - 0.5) * height / distance;
          break;
      }
      
      // 流れ星の軌道を計算（Z座標は一定）
      const startZ = -distance;
      const endZ = -distance;
      
      const start = new THREE.Vector3(startX, startY, startZ);
      const end = new THREE.Vector3(endX, endY, endZ);
      
      // 流れ星の尾のポイントを生成
      const points = [];
      const tailLength = 20; // 尾の長さ（ポイント数）
      for (let i = 0; i <= tailLength; i++) {
        const t = i / tailLength;
        const point = start.clone().lerp(end, t);
        points.push(point);
      }
      
      // 線のジオメトリを作成
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.8,
        linewidth: 2
      });
      
      const line = new THREE.Line(geometry, material);
      
      // 流れ星のデータを保存
      line.userData = {
        start: start,
        end: end,
        progress: 0,
        speed: 0.02 + Math.random() * 0.02, // ランダムな速度
        life: 0,
        maxLife: 2000 + Math.random() * 1000 // 2-3秒
      };
      
      scene.add(line);
      shootingStars.push(line);
    }
    
    // 流れ星を更新
    function updateShootingStars() {
      const now = Date.now();
      
      // 非定期的に新しい流れ星を生成（3-8秒間隔）
      if (now - lastShootingStarTime > 3000 + Math.random() * 5000) {
        createShootingStar();
        lastShootingStarTime = now;
      }
      
      // 既存の流れ星を更新
      for (let i = shootingStars.length - 1; i >= 0; i--) {
        const star = shootingStars[i];
        const data = star.userData;
        
        data.life += 16; // 約60fpsを想定
        data.progress += data.speed;
        
        // 流れ星の位置を更新
        const currentPos = data.start.clone().lerp(data.end, data.progress);
        const tailLength = 20;
        const points = [];
        
        for (let j = 0; j <= tailLength; j++) {
          const t = Math.max(0, data.progress - (j / tailLength) * 0.3);
          const point = data.start.clone().lerp(data.end, t);
          points.push(point);
        }
        
        // ジオメトリを更新
        star.geometry.setFromPoints(points);
        
        // 透明度を徐々に下げる
        const opacity = Math.max(0, 0.8 * (1 - data.life / data.maxLife));
        star.material.opacity = opacity;
        
        // 寿命が尽きたら削除
        if (data.life >= data.maxLife || data.progress >= 1) {
          scene.remove(star);
          star.geometry.dispose();
          star.material.dispose();
          shootingStars.splice(i, 1);
        }
      }
    }
    
    // 背景の星（装飾用）
    function createBackgroundStars() {
      const backgroundStars = new THREE.Group();
      const bgConfig = starConfig?.background || { starCount: 200, starSize: 0.1, starOpacity: 0.5 };
      
      for (let i = 0; i < bgConfig.starCount; i++) {
        const geometry = new THREE.SphereGeometry(bgConfig.starSize, 8, 8);
        const material = new THREE.MeshBasicMaterial({ 
          color: 0xffffff,
          opacity: bgConfig.starOpacity,
          transparent: true
        });
        const star = new THREE.Mesh(geometry, material);
        star.position.set(
          (Math.random() - 0.5) * 200,
          (Math.random() - 0.5) * 200,
          (Math.random() - 0.5) * 200
        );
        backgroundStars.add(star);
      }
      scene.add(backgroundStars);
    }
    
    // ラベル要素の作成
    let labelContainer = null;
    let labelElements = [];
    
    function createLabels() {
      if (labelContainer) return; // 既に作成済み
      
      labelContainer = document.createElement('div');
      labelContainer.style.position = 'absolute';
      labelContainer.style.top = '0';
      labelContainer.style.left = '0';
      labelContainer.style.width = '100%';
      labelContainer.style.height = '100%';
      labelContainer.style.pointerEvents = 'none';
      document.getElementById('canvas-container').appendChild(labelContainer);
      
      // 星のラベル要素を作成
      labelElements = stars.map(() => {
        const label = document.createElement('div');
        label.className = 'star-label';
        labelContainer.appendChild(label);
        return label;
      });
      
      // 太陽のラベル要素も作成
      const sunLabel = document.createElement('div');
      sunLabel.className = 'star-label';
      labelContainer.appendChild(sunLabel);
      window.sunLabel = sunLabel; // グローバルに保存
    }
    
    // 初期化関数
    async function initialize() {
      // 設定とデータを読み込む
      await loadConfig();
      await loadStarsData();
      
      // 設定を適用
      applyConfig();
      
      // 太陽を作成（ワールド座標の中心）
      const sun = createSun();
      
      // 星を作成
      createStars();
      scene.add(starsGroup);
      
      // 衛星をシーンに直接追加（starsGroupの回転の影響を受けないように）
      satellites.forEach(satellite => {
        scene.add(satellite);
      });
      
      // リンググループをシーンに追加
      scene.add(ringsGroup);
      
      // 背景の星を作成
      createBackgroundStars();
      
      // ラベル要素を作成
      createLabels();
      
      console.log(`Initialized ${stars.length} stars`);
      
      // アニメーションを開始
      startAnimation();
      
      // 戻りアニメーションをチェック
      checkReturnAnimation();
    }
    
    // 戻りアニメーションをチェック
    function checkReturnAnimation() {
      const urlParams = new URLSearchParams(window.location.search);
      const isReturn = urlParams.get('return') === 'true';
      
      if (isReturn) {
        // 戻りアニメーションを実行
        animateCameraReturn();
      }
    }
    
    // カメラを初期位置に戻すアニメーション
    function animateCameraReturn() {
      if (isAnimating) return;
      
      // URLパラメータから背景色を取得
      const urlParams = new URLSearchParams(window.location.search);
      const bgColorParam = urlParams.get('bg');
      let returnBgColor = new THREE.Color(0x000000);
      
      if (bgColorParam) {
        try {
          const colorValue = parseInt(bgColorParam, 16);
          returnBgColor = new THREE.Color(colorValue);
        } catch (e) {
          console.error('Invalid bg color parameter:', bgColorParam);
        }
      }
      
      // 背景色を設定（アニメーション開始時の色）
      scene.background.copy(returnBgColor);
      
      // どの星から戻ってきたかを特定（URLから推測、または最初に見つかった星を使用）
      let returnStar = null;
      const fromParam = urlParams.get('from');
      
      if (fromParam) {
        // 太陽の場合は特別に処理
        if (fromParam === 'sun.html' || fromParam.includes('sun')) {
          returnStar = scene.children.find(child => child.userData && child.userData.isSun);
        } else {
          // fromパラメータから星を特定
          returnStar = stars.find(star => {
            const starUrl = star.userData?.url || '';
            return starUrl.includes(fromParam) || star.userData?.name === fromParam;
          });
        }
      }
      
      // 星が見つからない場合は、背景色に最も近い星を探す
      if (!returnStar && bgColorParam) {
        const targetColor = new THREE.Color(parseInt(bgColorParam, 16));
        let closestStar = null;
        let minColorDiff = Infinity;
        
        // 通常の星を検索
        stars.forEach(star => {
          const starColor = star.material?.color || new THREE.Color(0xffffff);
          const colorDiff = starColor.distanceTo(targetColor);
          if (colorDiff < minColorDiff) {
            minColorDiff = colorDiff;
            closestStar = star;
          }
        });
        
        // 太陽も検索対象に含める
        const sun = scene.children.find(child => child.userData && child.userData.isSun);
        if (sun && sun.material) {
          const sunColor = sun.material.color || new THREE.Color(0xffd700);
          const sunColorDiff = sunColor.distanceTo(targetColor);
          if (sunColorDiff < minColorDiff) {
            minColorDiff = sunColorDiff;
            closestStar = sun;
          }
        }
        
        returnStar = closestStar;
      }
      
      // 星が見つからない場合は、太陽を使用
      if (!returnStar) {
        returnStar = scene.children.find(child => child.userData && child.userData.isSun);
      }
      
      // 少し待ってからアニメーションを開始（ページ読み込み完了を待つ）
      setTimeout(() => {
        if (isAnimating) return;
        
        isAnimating = true;
        animationStartTime = Date.now();
        
        // OrbitControlsを無効化
        controls.enabled = false;
        
        // 星のワールド座標を取得
        let starWorldPosition = new THREE.Vector3(0, 0, 0);
        if (returnStar) {
          returnStar.getWorldPosition(starWorldPosition);
        }
        
        // カメラを一旦星の方向に移動（アニメーション開始位置）
        const cameraDistance = starConfig?.animation?.cameraDistance || 5;
        const direction = starWorldPosition.clone().sub(camera.position).normalize();
        const startPosition = starWorldPosition.clone().sub(direction.multiplyScalar(cameraDistance));
        const startTarget = starWorldPosition.clone();
        
        // カメラを開始位置に設定
        camera.position.copy(startPosition);
        controls.target.copy(startTarget);
        camera.lookAt(controls.target);
        
        // 初期位置と目標位置
        const initialZ = starConfig?.camera?.initialZ || 50;
        const targetPosition = new THREE.Vector3(0, 0, initialZ);
        const targetLookAt = new THREE.Vector3(0, 0, 0);
        
        // 現在の背景色と初期背景色
        const startBgColor = scene.background.clone();
        const targetBgColor = new THREE.Color(0x000000);
        
        // アニメーション関数
        window.cameraAnimation = function() {
          const duration = starConfig?.animation?.duration || animationDuration;
          const elapsed = Date.now() - animationStartTime;
          const progress = Math.min(elapsed / duration, 1);
          
          // イージング関数（ease-in-out）
          const easeProgress = progress < 0.5
            ? 2 * progress * progress
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
          
          // カメラ位置を補間
          camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
          controls.target.lerpVectors(startTarget, targetLookAt, easeProgress);
          camera.lookAt(controls.target);
          
          // 背景色を徐々に黒色に戻す
          scene.background.lerpColors(startBgColor, targetBgColor, easeProgress);
          
          if (progress >= 1) {
            // アニメーション完了
            isAnimating = false;
            window.cameraAnimation = null;
            controls.enabled = true;
            
            // URLパラメータをクリーンアップ
            const url = new URL(window.location.href);
            url.searchParams.delete('return');
            url.searchParams.delete('bg');
            url.searchParams.delete('from');
            window.history.replaceState({}, '', url);
          }
        };
      }, 100); // 100ms待ってからアニメーション開始
    }
    
    // 初期化を実行
    initialize();
    
    // マウス移動時の処理
    let hoveredStar = null;
    
    function onMouseMove(event) {
      // canvasの相対座標を取得
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      // 太陽も含めて検出対象にする
      const sun = scene.children.find(child => child.userData && child.userData.isSun);
      const objectsToCheck = sun ? [...stars, sun] : stars;
      const intersects = raycaster.intersectObjects(objectsToCheck);
      
      // カーソルスタイルの変更
      if (intersects.length > 0) {
        document.body.style.cursor = 'pointer';
        let detectedObject = intersects[0].object;
        
        // グローオブジェクトの場合は親の星オブジェクトを取得
        if (detectedObject.parent && detectedObject.parent.userData && detectedObject.parent.userData.name) {
          hoveredStar = detectedObject.parent;
        } else if (detectedObject.userData && detectedObject.userData.name) {
          hoveredStar = detectedObject;
        } else {
          // 親を辿って星オブジェクトを探す
          let parent = detectedObject.parent;
          while (parent) {
            if (parent.userData && parent.userData.name) {
              hoveredStar = parent;
              break;
            }
            parent = parent.parent;
          }
          if (!hoveredStar) {
            hoveredStar = detectedObject;
          }
        }
      } else {
        document.body.style.cursor = 'default';
        hoveredStar = null;
      }
      
      // ラベルの更新
      updateLabels();
    }
    
    function updateLabels() {
      stars.forEach((star, index) => {
        const label = labelElements[index];
        
        // 星のワールド座標を取得（starsGroupの回転や親子関係を考慮）
        const worldPosition = new THREE.Vector3();
        star.getWorldPosition(worldPosition);
        
        // カメラ座標系に変換
        const vector = worldPosition.clone();
        vector.project(camera);
        
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        
        label.style.left = x + 'px';
        label.style.top = y + 'px';
        label.textContent = star.userData.name;
        
        // 星が画面内にある場合のみ表示
        if (vector.z < 1 && star === hoveredStar) {
          label.classList.add('visible');
        } else {
          label.classList.remove('visible');
        }
      });
      
      // 太陽のラベルも更新
      if (window.sunLabel) {
        const sun = scene.children.find(child => child.userData && child.userData.isSun);
        if (sun) {
          const worldPosition = new THREE.Vector3();
          sun.getWorldPosition(worldPosition);
          const vector = worldPosition.clone();
          vector.project(camera);
          
          const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
          
          window.sunLabel.style.left = x + 'px';
          window.sunLabel.style.top = y + 'px';
          window.sunLabel.textContent = sun.userData.name;
          
          if (vector.z < 1 && hoveredStar === sun) {
            window.sunLabel.classList.add('visible');
          } else {
            window.sunLabel.classList.remove('visible');
          }
        }
      }
    }
    
    // カメラアニメーション用の変数
    let isAnimating = false;
    let animationStartTime = 0;
    const animationDuration = 2000; // 2秒
    
    // 星に向かってカメラを移動するアニメーション
    function animateCameraToStar(star, url, starColor, callback) {
      if (isAnimating) return;
      
      isAnimating = true;
      animationStartTime = Date.now();
      
      // OrbitControlsを無効化
      controls.enabled = false;
      
      // カメラの開始位置と目標位置
      const startPosition = camera.position.clone();
      const startTarget = controls.target.clone();
      
      // 星のワールド座標を取得
      const starWorldPosition = new THREE.Vector3();
      star.getWorldPosition(starWorldPosition);
      
      // 星の位置を目標とする（少し手前に）
      const cameraDistance = starConfig?.animation?.cameraDistance || 5;
      const direction = starWorldPosition.clone().sub(camera.position).normalize();
      const targetPosition = starWorldPosition.clone().sub(direction.multiplyScalar(cameraDistance));
      const targetLookAt = starWorldPosition.clone();
      
      // 初期背景色を保存
      const startBgColor = scene.background.clone();
      const targetBgColor = new THREE.Color(starColor);
      
      // コールバックに必要なデータを保存
      // URLと色を文字列として保存（確実に保存されるように）
      window.animationCallback = callback;
      window.animationUrl = String(url || ''); // 文字列に変換して保存
      window.animationStarColor = Number(starColor || 0); // 数値に変換して保存
      
      console.log('Animation started:', {
        startPosition: startPosition,
        targetPosition: targetPosition,
        starWorldPosition: starWorldPosition,
        starColor: starColor,
        url: url,
        urlType: typeof url,
        callback: callback ? 'exists' : 'missing',
        savedUrl: window.animationUrl,
        savedUrlType: typeof window.animationUrl,
        savedColor: window.animationStarColor
      });
      
      // URLが空の場合はエラー
      if (!url || url === '') {
        console.error('URL is empty or invalid:', url);
        isAnimating = false;
        return;
      }
      
      // アニメーション関数（メインループから呼ばれる）
      window.cameraAnimation = function() {
        const duration = starConfig?.animation?.duration || animationDuration;
        const elapsed = Date.now() - animationStartTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // イージング関数（ease-in-out）
        const easeProgress = progress < 0.5
          ? 2 * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;
        
        // カメラ位置を補間
        camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
        controls.target.lerpVectors(startTarget, targetLookAt, easeProgress);
        camera.lookAt(controls.target);
        
        // 背景色を徐々に星の色に変更
        scene.background.lerpColors(startBgColor, targetBgColor, easeProgress);
        
        // 星を拡大
        const baseScale = star.userData.baseScale || 1;
        const scaleMultiplier = starConfig?.animation?.scaleMultiplier || 2.0;
        const scale = baseScale + easeProgress * scaleMultiplier;
        star.scale.set(scale, scale, scale);
        
        if (progress >= 1) {
          // アニメーション完了
          console.log('Animation completed, calling callback');
          isAnimating = false;
          window.cameraAnimation = null;
          
          // データを取得（クリーンアップ前に）
          const cb = window.animationCallback;
          let cbUrl = window.animationUrl;
          let cbColor = window.animationStarColor;
          
          // データがundefinedの場合は、空文字列や0に変換
          if (cbUrl === undefined || cbUrl === null) {
            cbUrl = '';
          }
          if (cbColor === undefined || cbColor === null) {
            cbColor = 0;
          }
          
          console.log('Callback data:', {
            callback: cb ? 'exists' : 'missing',
            url: cbUrl,
            color: cbColor,
            urlType: typeof cbUrl,
            colorType: typeof cbColor,
            windowAnimationUrl: window.animationUrl,
            windowAnimationStarColor: window.animationStarColor
          });
          
          // クリーンアップ（コールバック実行前）
          window.animationCallback = null;
          window.animationUrl = null;
          window.animationStarColor = null;
          
          if (cb && cbUrl && cbUrl !== '' && cbColor !== undefined && cbColor !== 0) {
            console.log('Executing callback with url:', cbUrl, 'color:', cbColor);
            try {
              cb(cbUrl, cbColor);
            } catch (e) {
              console.error('Error in callback:', e);
            }
          } else {
            console.error('Callback or data is missing!', {
              callback: cb ? 'exists' : 'missing',
              url: cbUrl,
              color: cbColor,
              urlEmpty: !cbUrl || cbUrl === '',
              colorInvalid: cbColor === undefined || cbColor === 0
            });
          }
        }
      };
    }
    
    // クリック時の処理
    function onMouseClick(event) {
      if (hoveredStar && !isAnimating) {
        console.log('Click detected, hoveredStar:', hoveredStar);
        console.log('hoveredStar.userData:', hoveredStar.userData);
        console.log('hoveredStar type:', hoveredStar.constructor.name);
        console.log('stars array:', stars);
        console.log('stars length:', stars.length);
        
        // 星の配列から該当する星を探す
        let actualStar = null;
        for (let i = 0; i < stars.length; i++) {
          if (stars[i] === hoveredStar || stars[i].uuid === hoveredStar.uuid) {
            actualStar = stars[i];
            break;
          }
        }
        
        // 見つからない場合は、hoveredStarをそのまま使用
        const targetStar = actualStar || hoveredStar;
        
        // userDataから直接取得
        const starData = targetStar.userData;
        const url = starData ? starData.url : null;
        const starColor = targetStar.material ? targetStar.material.color.getHex() : 0xffffff;
        
        console.log('Star clicked:', {
          name: starData ? starData.name : 'unknown',
          url: url,
          color: starColor,
          userData: starData,
          hasUrl: !!url,
          urlType: typeof url,
          targetStar: targetStar,
          isActualStar: actualStar !== null
        });
        
        // URLが存在しない場合はエラー
        if (!url || url === '' || url === undefined) {
          console.error('URL is missing for star:', starData ? starData.name : 'unknown', 'userData:', starData);
          console.error('targetStar:', targetStar);
          console.error('All stars userData:', stars.map(s => ({ name: s.userData?.name, url: s.userData?.url })));
          return;
        }
        
        // カメラアニメーションを実行してから遷移
        // コールバック内で直接URLと色を使用（確実に渡されるように）
        const navigationUrl = String(url);
        const navigationColor = Number(starColor);
        
        animateCameraToStar(targetStar, navigationUrl, navigationColor, (finalUrl, finalColor) => {
          console.log('Callback received:', { finalUrl, finalColor, finalUrlType: typeof finalUrl });
          
          // 引数の検証
          if (!finalUrl || finalUrl === '' || finalColor === undefined || finalColor === 0) {
            console.error('Invalid callback arguments:', { finalUrl, finalColor });
            // フォールバック: 直接遷移を試みる
            const fallbackUrl = navigationUrl;
            const fallbackColor = navigationColor;
            const colorHex = fallbackColor.toString(16).padStart(6, '0');
            const separator = fallbackUrl.includes('?') ? '&' : '?';
            const urlWithColor = `${fallbackUrl}${separator}bg=${colorHex}`;
            console.log('Using fallback, navigating to:', urlWithColor);
            window.location.href = urlWithColor;
            return;
          }
          
          // 星の色をURLパラメータに追加
          const colorHex = finalColor.toString(16).padStart(6, '0');
          const separator = finalUrl.includes('?') ? '&' : '?';
          const urlWithColor = `${finalUrl}${separator}bg=${colorHex}`;
          
          console.log('Navigating to:', urlWithColor);
          
          // 少し遅延を入れてから遷移（視覚効果のため）
          setTimeout(() => {
            window.location.href = urlWithColor;
          }, 200);
        });
      }
    }
    
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('click', onMouseClick);
    
    // アニメーションループ
    function animate() {
      requestAnimationFrame(animate);
      
      // カメラアニメーションが実行中の場合はそれを実行
      if (window.cameraAnimation) {
        window.cameraAnimation();
      } else {
        // 通常のアニメーション
        // 星を回転させる
        starsGroup.rotation.y += 0.001;
        starsGroup.rotation.x += 0.0005;
        
        const time = Date.now() * 0.001;
        
        // 太陽を回転させる（ゆっくりと）
        const sun = scene.children.find(child => child.userData && child.userData.isSun);
        if (sun) {
          sun.rotation.y += 0.0005;
          sun.rotation.x += 0.0003;
          
          // 太陽のサイズを脈動させる
          const sunScale = 1 + Math.sin(time * 1.5) * 0.05;
          sun.scale.set(sunScale, sunScale, sunScale);
        }
        
        // 惑星と通常の星を漂わせる（衛星は除外）
        stars.forEach((star, index) => {
          // 衛星は軌道計算で位置が決まるのでスキップ
          if (star.userData.type === 'satellite') {
            return;
          }
          
          const offset = index * 0.5;
          star.position.x += Math.sin(time + offset) * 0.01;
          star.position.y += Math.cos(time + offset * 1.3) * 0.01;
          star.position.z += Math.sin(time + offset * 0.7) * 0.01;
          
          // 星のサイズを脈動させる
          const scale = 1 + Math.sin(time * 2 + offset) * 0.1;
          star.scale.set(scale, scale, scale);
          
          // 惑星のリングの位置を同期し、回転させる
          if (star.userData.hasSatellites && star.userData.satellites) {
            // 親星のワールド座標を取得
            const starWorldPos = new THREE.Vector3();
            star.getWorldPosition(starWorldPos);
            
            star.userData.satellites.forEach(satellite => {
              if (satellite.userData.ring) {
                const ring = satellite.userData.ring;
                // リングの位置を親星のワールド座標に同期
                ring.position.copy(starWorldPos);
                // リングを回転させる（子星の軌道速度に合わせる）
                ring.rotation.z += satellite.userData.orbitSpeed * 0.01;
              }
            });
          }
        });
        
        // 衛星を親星を基準にリングと同じ軸で回転させる
        satellites.forEach(satellite => {
          const parent = satellite.userData.parent;
          if (!parent) return;
          
          const ring = satellite.userData.ring;
          if (!ring) return;
          
          // 親星のワールド座標を取得
          const parentWorldPos = new THREE.Vector3();
          parent.getWorldPosition(parentWorldPos);
          
          // リングの回転角度を使用（リングと同じ軸で回転）
          const angle = ring.rotation.z;
          const radius = satellite.userData.orbitRadius;
          
          // リング上の位置（XY平面のみ、Y座標は固定）
          const x = Math.cos(angle) * radius;
          const y = 0; // リング上なのでY座標は固定
          const z = Math.sin(angle) * radius;
          
          // 親星のワールド座標を基準に衛星の位置を設定
          // starsGroupの回転の影響を受けないように、親星のワールド座標を使用
          satellite.position.set(
            parentWorldPos.x + x,
            parentWorldPos.y + y,
            parentWorldPos.z + z
          );
          
          // 子星の回転角度をリングの角度に合わせる（リングと同じ軸で回転）
          satellite.rotation.z = angle;
          
          // 衛星のサイズを脈動させる
          const scale = 1 + Math.sin(time * 2) * 0.1;
          satellite.scale.set(scale, scale, scale);
        });
      }
      
      controls.update();
      updateLabels();
      updateShootingStars(); // 流れ星を更新
      renderer.render(scene, camera);
    }
    
    // リサイズ処理
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    window.addEventListener('resize', onWindowResize);
    
    // アニメーション開始（初期化完了後に開始）
    let animationStarted = false;
    function startAnimation() {
      if (!animationStarted) {
        animationStarted = true;
        animate();
      }
    }
  </script>
</body>
</html>
